
local lexical_path = require("lexical-path")
local unix = lexical_path.from_unix
local luassert = require("luassert")

describe("lexical-path", function()
   describe("remove_leading", function()
      it("should remove the leading components of the path", function()
         local p = unix("foo/bar/baz")
         local leading = unix("foo/bar")
         local result, err = p:remove_leading(leading)
         luassert.is_not_nil(result, err)
         luassert.equal(result, unix("baz"), "Expected foo/bar/baz with foo/bar removed to be baz")
      end)

      it("should error when mixing abolute and non-absolute paths", function()
         local p = unix("/foo")
         local leading = unix("foo")
         local result, err = p:remove_leading(leading)
         luassert.is_nil(result, "Expected result to be nil")
         luassert.truthy(err, "Expected err to be truthy")
         luassert.equal(err, "Mixing of absolute and non-absolute path", "Error message was incorrect")
      end)
   end)

   describe("from_components", function()
      it("should be able to construct a simple path", function()
         local p, normalized, index = lexical_path.from_components({ "a", "b", "c" })
         luassert.equal("a", p[1], "Expected first component to be 'a'")
         luassert.equal("b", p[2], "Expected second component to be 'b'")
         luassert.equal("c", p[3], "Expected third component to be 'c'")
         luassert.equal("normal", normalized, "Expected components a/b/c to not need normalization")
         luassert.is_nil(index, "Expected normalization index to be nil")
      end)

      it("should report when a path is normalized", function()
         local p, normalized, index = lexical_path.from_components({ "a", "b", "..", "c" })
         luassert.equal("a", p[1], "Expected first component to be 'a'")
         luassert.equal("c", p[2], "Expected second component to be 'c'")
         luassert.equal("non-normal", normalized, "Expected components a/b/../c to need normalization")
         luassert.equal(3, index, "Expected third component of a/b/../c to need normalization")
      end)
   end)

   describe("is_normalized", function()
      it("should consider an otherwise normal path with leading .. normal", function()
         local p = unix("../../a/b")
         luassert.equal("..", p[1], "Expected first component to be '..'")
         luassert.equal("..", p[2], "Expected second component to be '..'")
         luassert.equal("a", p[3], "Expected third component to be 'a'")
         luassert.equal("b", p[4], "Expected fourth component to be 'b'")
         local is_normal, bad_index = p:is_normalized()
         luassert.is_true(is_normal, "Expected path to be normalized, but component " .. tostring(bad_index) .. " wasn't")
      end)
   end)
end)
